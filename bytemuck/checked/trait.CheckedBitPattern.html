<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A marker trait that allows types that have some invalid bit patterns to be used in places that otherwise require `AnyBitPattern` or `Pod` types by performing a runtime check on a perticular set of bits. This is particularly useful for types like fieldless (‘C-style’) enums, `char`, bool, and structs containing them."><title>CheckedBitPattern in bytemuck::checked - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bytemuck" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../bytemuck/index.html">bytemuck</a><span class="version">1.12.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Checked<wbr>BitPattern</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#derive" title="Derive">Derive</a></li><li><a href="#example" title="Example">Example</a></li><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Bits" title="Bits">Bits</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.is_valid_bit_pattern" title="is_valid_bit_pattern">is_valid_bit_pattern</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-CheckedBitPattern-for-bool" title="bool">bool</a></li><li><a href="#impl-CheckedBitPattern-for-char" title="char">char</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In bytemuck::<wbr>checked</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bytemuck</a>::<wbr><a href="index.html">checked</a></span><h1>Trait <span class="trait">CheckedBitPattern</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bytemuck/checked.rs.html#130-141">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe trait CheckedBitPattern: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> {
    type <a href="#associatedtype.Bits" class="associatedtype">Bits</a>: <a class="trait" href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern">AnyBitPattern</a>;

    // Required method
    fn <a href="#tymethod.is_valid_bit_pattern" class="fn">is_valid_bit_pattern</a>(bits: &amp;Self::<a class="associatedtype" href="trait.CheckedBitPattern.html#associatedtype.Bits" title="type bytemuck::checked::CheckedBitPattern::Bits">Bits</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.bool.html">bool</a>;
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A marker trait that allows types that have some invalid bit patterns to be
used in places that otherwise require <a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a> or <a href="../trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> types by
performing a runtime check on a perticular set of bits. This is particularly
useful for types like fieldless (‘C-style’) enums, <a href="https://doc.rust-lang.org/1.85.0/core/primitive.char.html" title="primitive char"><code>char</code></a>, bool, and
structs containing them.</p>
<p>To do this, we define a <code>Bits</code> type which is a type with equivalent layout
to <code>Self</code> other than the invalid bit patterns which disallow <code>Self</code> from
being <a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a>. This <code>Bits</code> type must itself implement
<a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a>. Then, we implement a function that checks wheter a
certain instance of the <code>Bits</code> is also a valid bit pattern of <code>Self</code>. If
this check passes, then we can allow casting from the <code>Bits</code> to <code>Self</code> (and
therefore, any type which is able to be cast to <code>Bits</code> is also able to be
cast to <code>Self</code>).</p>
<p><a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a> is a subset of <a href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern"><code>CheckedBitPattern</code></a>, meaning that any <code>T: AnyBitPattern</code> is also <a href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern"><code>CheckedBitPattern</code></a>. This means you can also use
any <a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a> type in the checked versions of casting functions in
this module. If it’s possible, prefer implementing <a href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a> for
your type directly instead of <a href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern"><code>CheckedBitPattern</code></a> as it gives greater
flexibility.</p>
<h2 id="derive"><a class="doc-anchor" href="#derive">§</a>Derive</h2>
<p>A <code>#[derive(CheckedBitPattern)]</code> macro is provided under the <code>derive</code>
feature flag which will automatically validate the requirements of this
trait and implement the trait for you for both enums and structs. This is
the recommended method for implementing the trait, however it’s also
possible to do manually.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>If manually implementing the trait, we can do something like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bytemuck::{CheckedBitPattern, NoUninit};

<span class="attr">#[repr(u32)]
#[derive(Copy, Clone)]
</span><span class="kw">enum </span>MyEnum {
    Variant0 = <span class="number">0</span>,
    Variant1 = <span class="number">1</span>,
    Variant2 = <span class="number">2</span>,
}

<span class="kw">unsafe impl </span>CheckedBitPattern <span class="kw">for </span>MyEnum {
    <span class="kw">type </span>Bits = u32;

    <span class="kw">fn </span>is_valid_bit_pattern(bits: <span class="kw-2">&amp;</span>u32) -&gt; bool {
        <span class="kw">match </span><span class="kw-2">*</span>bits {
            <span class="number">0 </span>| <span class="number">1 </span>| <span class="number">2 </span>=&gt; <span class="bool-val">true</span>,
            <span class="kw">_ </span>=&gt; <span class="bool-val">false</span>,
        }
    }
}

<span class="comment">// It is often useful to also implement `NoUninit` on our `CheckedBitPattern` types.
// This will allow us to do casting of mutable references (and mutable slices).
// It is not always possible to do so, but in this case we have no padding so it is.
</span><span class="kw">unsafe impl </span>NoUninit <span class="kw">for </span>MyEnum {}</code></pre></div>
<p>We can now use relevant casting functions. For example,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bytemuck::{bytes_of, bytes_of_mut};
<span class="kw">use </span>bytemuck::checked;

<span class="kw">let </span>bytes = bytes_of(<span class="kw-2">&amp;</span><span class="number">2u32</span>);
<span class="kw">let </span>result = checked::try_from_bytes::&lt;MyEnum&gt;(bytes);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span>MyEnum::Variant2));

<span class="comment">// Fails for invalid discriminant
</span><span class="kw">let </span>bytes = bytes_of(<span class="kw-2">&amp;</span><span class="number">100u32</span>);
<span class="kw">let </span>result = checked::try_from_bytes::&lt;MyEnum&gt;(bytes);
<span class="macro">assert!</span>(result.is_err());

<span class="comment">// Since we implemented NoUninit, we can also cast mutably from an original type
// that is `NoUninit + AnyBitPattern`:
</span><span class="kw">let </span><span class="kw-2">mut </span>my_u32 = <span class="number">2u32</span>;
{
  <span class="kw">let </span>as_enum_mut = checked::cast_mut::&lt;<span class="kw">_</span>, MyEnum&gt;(<span class="kw-2">&amp;mut </span>my_u32);
  <span class="macro">assert_eq!</span>(as_enum_mut, <span class="kw-2">&amp;mut </span>MyEnum::Variant2);
  <span class="kw-2">*</span>as_enum_mut = MyEnum::Variant0;
}
<span class="macro">assert_eq!</span>(my_u32, <span class="number">0u32</span>);</code></pre></div>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<ul>
<li><code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> except for
the possible invalid bit patterns being checked during
<a href="trait.CheckedBitPattern.html#tymethod.is_valid_bit_pattern" title="associated function bytemuck::checked::CheckedBitPattern::is_valid_bit_pattern"><code>is_valid_bit_pattern</code></a>.
<ul>
<li>This almost certainly means your type must be <code>#[repr(C)]</code> or a similar
specified repr, but if you think you know better, you probably don’t. If
you   still think you know better, be careful and have fun. And don’t mess
it up   (I mean it).</li>
</ul>
</li>
<li>If <a href="trait.CheckedBitPattern.html#tymethod.is_valid_bit_pattern" title="associated function bytemuck::checked::CheckedBitPattern::is_valid_bit_pattern"><code>is_valid_bit_pattern</code></a> returns true, then the bit pattern contained
in <code>bits</code> must also be valid for an instance of <code>Self</code>.</li>
<li>Probably more, don’t mess it up (I mean it 2.0)</li>
</ul>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Bits" class="method"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#136">Source</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a>: <a class="trait" href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern">AnyBitPattern</a></h4></section></summary><div class="docblock"><p><code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> except for
the possible invalid bit patterns being checked during
<a href="trait.CheckedBitPattern.html#tymethod.is_valid_bit_pattern" title="associated function bytemuck::checked::CheckedBitPattern::is_valid_bit_pattern"><code>is_valid_bit_pattern</code></a>.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.is_valid_bit_pattern" class="method"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#140">Source</a><h4 class="code-header">fn <a href="#tymethod.is_valid_bit_pattern" class="fn">is_valid_bit_pattern</a>(bits: &amp;Self::<a class="associatedtype" href="trait.CheckedBitPattern.html#associatedtype.Bits" title="type bytemuck::checked::CheckedBitPattern::Bits">Bits</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>If this function returns true, then it must be valid to reinterpret <code>bits</code>
as <code>&amp;Self</code>.</p>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.85.0/reference/items/traits.html#object-safety">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-CheckedBitPattern-for-bool" class="impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#161-171">Source</a><a href="#impl-CheckedBitPattern-for-bool" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern">CheckedBitPattern</a> for <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.bool.html">bool</a></h3></section></summary><div class="impl-items"><section id="associatedtype.Bits-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#162">Source</a><a href="#associatedtype.Bits-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a> = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.u8.html">u8</a></h4></section><section id="method.is_valid_bit_pattern" class="method trait-impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#165-170">Source</a><a href="#method.is_valid_bit_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_valid_bit_pattern" class="fn">is_valid_bit_pattern</a>(bits: &amp;Self::<a class="associatedtype" href="trait.CheckedBitPattern.html#associatedtype.Bits" title="type bytemuck::checked::CheckedBitPattern::Bits">Bits</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.bool.html">bool</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CheckedBitPattern-for-char" class="impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#152-159">Source</a><a href="#impl-CheckedBitPattern-for-char" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern">CheckedBitPattern</a> for <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.char.html">char</a></h3></section></summary><div class="impl-items"><section id="associatedtype.Bits-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#153">Source</a><a href="#associatedtype.Bits-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a> = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.u32.html">u32</a></h4></section><section id="method.is_valid_bit_pattern-1" class="method trait-impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#156-158">Source</a><a href="#method.is_valid_bit_pattern-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_valid_bit_pattern" class="fn">is_valid_bit_pattern</a>(bits: &amp;Self::<a class="associatedtype" href="trait.CheckedBitPattern.html#associatedtype.Bits" title="type bytemuck::checked::CheckedBitPattern::Bits">Bits</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/core/primitive.bool.html">bool</a></h4></section></div></details><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-CheckedBitPattern-for-T" class="impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#143-150">Source</a><a href="#impl-CheckedBitPattern-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern">AnyBitPattern</a>&gt; <a class="trait" href="trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern">CheckedBitPattern</a> for T</h3></section></summary><div class="impl-items"><section id="associatedtype.Bits-3" class="associatedtype trait-impl"><a class="src rightside" href="../../src/bytemuck/checked.rs.html#144">Source</a><a href="#associatedtype.Bits-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a> = T</h4></section></div></details></div><script src="../../trait.impl/bytemuck/checked/trait.CheckedBitPattern.js" data-ignore-extern-crates="core" async></script></section></div></main></body></html>