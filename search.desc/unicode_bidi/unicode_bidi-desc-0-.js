searchState.loadedDescShard("unicode_bidi", 0, "This crate implements the Unicode Bidirectional Algorithm …\nRepresents values of the Unicode character property …\nBidi information of the text.\nHardcoded Bidi data that ships with the unicode-bidi crate.\nInitial bidi information of the text.\nA maximal substring of characters with the same embedding …\nContains a reference of <code>BidiInfo</code> and one of its <code>paragraphs</code>.\nBidi information about a single paragraph\nThe Unicode version of data\nFind the <code>BidiClass</code> of a single char.\nThis module holds deprecated assets only.\nReturns if the paragraph is Left direction, right …\nThe upper bound of the range (exclusive).\nDirectional Formatting Characters\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf processed text has any computed RTL levels\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets the length of the paragraph in the source text.\nBidi Embedding Level\nThe paragraph embedding level.\nReturns the <code>Level</code> of a certain character in the paragraph.\nThe directional embedding level of each byte in the text.\nFind the paragraphs and BidiClasses in a string of text.\nSplit the text into paragraphs and determine the bidi …\nFind the paragraphs and BidiClasses in a string of text, …\nSplit the text into paragraphs and determine the bidi …\nThe BidiClass of the character at each byte in the text. …\nThe BidiClass of the character at each byte in the text.\nThe boundaries and level of each paragraph within the text.\nThe boundaries and paragraph embedding level of each …\nThe paragraphs boundaries within the text, as byte indices.\nRe-order a line based on resolved levels and return the …\nRe-order a line based on resolved levels and return only …\nRe-order a line based on resolved levels and return only …\nThe lower bound of the range (inclusive).\nThe text\nThe text\nFind the level runs within a line and return them in …\nThis trait abstracts over a data source that is able to …\nFind the level runs within a line and return them in …\nARABIC LETTER MARK\nFIRST STRONG ISOLATE\nLEFT-TO-RIGHT EMBEDDING\nLEFT‑TO‑RIGHT ISOLATE\nLEFT-TO-RIGHT MARK\nLEFT-TO-RIGHT OVERRIDE\nPOP DIRECTIONAL FORMATTING\nPOP DIRECTIONAL ISOLATE\nRIGHT-TO-LEFT EMBEDDING\nRIGHT‑TO‑LEFT ISOLATE\nRIGHT-TO-LEFT MARK\nRIGHT-TO-LEFT OVERRIDE\nErrors that can occur on Level creation or mutation\nEmbedding Level\nDuring explicit level resolution, embedding level can go …\nDuring implicit level resolution, embedding level can go …\nOut-of-range (invalid) embedding level number.\nGenerate a character type based on a level (as specified …\nReturns the argument unchanged.\nCreate level by number\nReturns the argument unchanged.\nIf levels has any RTL (odd) level\nCalls <code>U::from(self)</code>.\nConvert to the level number\nCalls <code>U::from(self)</code>.\nIf this level is left-to-right.\nIf this level is right-to-left.\nLower level by <code>amount</code>, fail if number goes below zero.\nNew LTR level with smallest number value (0).\nMaximum depth of the directional status stack during …\nMaximum depth of the directional status stack during …\nCreate new level, fail if number is larger than …\nCreate new level, fail if number is larger than <code>max_depth</code>.\nThe next LTR (even) level greater than this, or fail if …\nThe next RTL (odd) level greater than this, or fail if …\nThe lowest RTL (odd) level greater than or equal to this, …\nThe level number.\nRaise level by <code>amount</code>, fail if number is larger than …\nRaise level by <code>amount</code>, fail if number is larger than …\nNew RTL level with smallest number value (1).")