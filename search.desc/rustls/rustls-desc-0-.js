searchState.loadedDescShard("rustls", 0, "Rustls - a modern TLS library\nA list of all the cipher suites supported by rustls.\nA list of all the key exchange groups supported by rustls.\nA list of all the protocol versions supported by rustls.\nAES with 128-bit keys in Galois counter mode.\nAES with 256-bit keys in Galois counter mode.\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nBulk symmetric encryption scheme used by a cipher suite.\nThis type contains a single certificate by value.\nChacha20 for confidentiality with poly1305 for …\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nA client connection\nConnection state common to both client and server …\nBuilding a <code>ServerConfig</code> or <code>ClientConfig</code> in a …\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nA client or server connection.\nInterface shared by client and server connections.\nThe peer sent us a syntactically incorrect TLS message.\nThe peer sent us a TLS message with invalid contents.\nThe cipher suite configuration that an application should …\nThe version configuration that an application should use …\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nWe received a certificate which includes invalid data.\nWe received an invalidly encoded certificate from the peer.\nWe received a certificate with invalid signature.\nWe received a certificate with invalid signature type.\nThe presented SCT(s) were invalid.\nValues of this structure are returned from …\nThis trait represents the ability to do something useful …\n<code>KeyLog</code> implementation that opens a file whose name is …\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nKeyLog that does exactly nothing.\nA trust anchor, commonly known as a “Root Certificate.”\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThis type contains a private key by value.\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nA structure that implements <code>std::io::Read</code> for reading …\nA container for root certificates able to provide a …\nA server connection\nData specific to the peer’s side (client or server).\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nA cipher suite supported by rustls.\nA key-exchange group supported by rustls.\nA TLS protocol version supported by rustls.\nA concrete, safe ticket creation mechanism.\nA TLS 1.2 cipher suite\nA TLS 1.2 cipher suite supported by rustls.\nA TLS 1.3 cipher suite\nA TLS 1.3 cipher suite supported by rustls.\nThe certificate verifier doesn’t support the given type …\nConfig builder state where the caller must supply cipher …\nConfig builder state where the caller must supply key …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nA structure that implements <code>std::io::Write</code> for writing …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nRetrieves the protocol agreed with the peer via ALPN.\nCan a session using suite self resume from suite prev?\nAll defined ciphersuites appear in this module.\nItems for use in a client.\nCommon cipher suite fields.\nCommon cipher suite fields.\nThis function uses <code>io</code> to complete any outstanding IO for …\nThis function uses <code>io</code> to complete any outstanding IO for …\nOur TLS connection\nOur connection\nDerive a <code>MessageDecrypter</code> object from the concerned TLS 1.3\nMake a new, empty <code>RootCertStore</code>.\nThis is a non-standard extension which extends the key …\nDerives key material from the agreed connection secrets.\nDerives key material from the agreed connection secrets.\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an <code>OwnedTrustAnchor</code> from its components.\nGet a mutable reference to the underlying socket\nGet a reference to the underlying socket\nWhich hash function to use with this suite.\nWhich hash function to use with this suite.\nWhich hash function to use with this suite.\nInternal classes which may be useful outside the library. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if there are no certificates.\nReturns true if the connection is currently performing the …\nHow to exchange/agree keys.\nAll defined key exchange groups appear in this module.\nSay how many certificates are in the container.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nThis is the rustls manual.\nThe IANA “TLS Supported Groups” name of the group\nRetrieves the ciphersuite agreed with the peer.\nMakes a new <code>KeyLogFile</code>.  The environment variable is …\nMake the recommended Ticketer.  This produces tickets with …\nMake a new Stream using the Connection <code>conn</code> and …\nMake a new StreamOwned taking the Connection <code>conn</code> and …\nRetrieves the certificate chain used by the peer to …\nTrue if the peer has sent us a close_notify alert.  This is\nHow many plaintext bytes could be obtained via …\nProcesses any new packets read by a previous call to …\nProcesses any new packets read by a previous call to …\nRetrieves the protocol version agreed with the peer.\nObtain plaintext data received from the peer over this TLS …\nRead TLS content from <code>rd</code>.\nRead TLS content from <code>rd</code>.  This method does internal …\nReturns an object that allows reading plaintext.\nReturns an object that allows reading plaintext.\nResolve the set of supported <code>SignatureScheme</code>s from the …\nThe list of roots.\nQueues a close_notify warning alert to be sent in the next …\nItems for use in a server.\nSets a limit on the internal buffers used to buffer unsent …\nMessage signing interfaces and implementations.\nHow to sign messages for authentication.\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nReturn the Subject Names for certificates in the container.\nThe cipher suite’s identifier\nHow many bytes could be written by <code>CommonState::write_tls</code> …\nReturn true if this suite is usable for a key only …\nAll defined protocol versions appear in this module.\nReturn supported protocol version for the cipher suite.\nThe TLS enumeration naming this version.\nReturns true if the caller should call <code>Connection::read_tls</code>…\nReturns true if the caller should call …\nIndicates whether the secret with label <code>label</code> will be …\nIndicates whether the secret with label <code>label</code> will be …\nSets a custom <code>ResolvesServerCert</code>.\nSet Certificate Transparency logs to use for server …\nChoose a specific set of cipher suites.\nSets a custom <code>ResolvesClientCert</code>.\nSets a custom <code>ResolvesClientCert</code>.\nChoose how to verify client certificates.\nChoose a specific set of key exchange groups.\nDo not support client auth.\nDo not support client auth.\nDisable client authentication.\nUse a specific set of protocol versions.\nChoose how to verify client certificates.\nChoose the default set of cipher suites (…\nChoose the default set of key exchange groups (…\nAccept the default protocol versions: both TLS1.2 and …\nStart side-specific config with defaults for underlying …\nSets a single certificate chain and matching private key.  …\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key …\nSets a single certificate chain, matching private key, OCSP\nSend the plaintext <code>buf</code> to the peer, encrypting and …\nWrites TLS messages to <code>wr</code>.\nReturns an object that allows writing plaintext.\nReturns an object that allows writing plaintext.\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nHow to do bulk encryption.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe TLS enumeration naming this cipher suite.\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nAn implementer of <code>StoresClientSessions</code> that stores …\nThe server is identified by a DNS name.  The name is sent …\nThe provided input could not be parsed because it is not a …\nThe server is identified by an IP address. SNI is not done.\nAn implementer of <code>StoresClientSessions</code> which does nothing.\nA trait for the ability to choose a certificate chain and …\nEncodes ways a client can know the expected name of the …\nA trait for the ability to store client session data. The …\nA config builder state where the caller needs to supply …\nA config builder state where the caller needs to supply a …\nStub that implements io::Write and dispatches to …\nWhich ALPN protocols we include in our client hello. If …\nCreate a builder to build up the client configuration.\nHow many bytes you may send.  Writes will become short …\nHow to decide what client auth certificate/keys to use.\nReturns an <code>io::Write</code> implementer you can write bytes to to …\nWhether to send data on the first flight (“early data”…\nWhether to send the Server Name Indication (SNI) extension …\nWhether to support RFC5077 tickets.  You must provide a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the latest value for <code>key</code>.  Returns <code>None</code> if there’…\nReturn true if any certificates at all are available.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nHow to output key material for debugging.  The default …\nThe maximum size of TLS message we’ll emit.  If None, we …\nMake a new ClientConnection.  <code>config</code> controls how we …\nMake a new ClientSessionMemoryCache.  <code>size</code> is the maximum …\nStores a new <code>value</code> for <code>key</code>.  Returns <code>true</code> if the value was …\nWith the server-supplied acceptable issuers in …\nHow we store session data or tickets.\nLow-level TLS message decryption functions.\nLow-level TLS message parsing and encoding functions.\nObjects with this trait can decrypt TLS messages.\nPerform the decryption over the concerned TLS message.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn externally length’d payload\nAn arbitrary, unknown-content, u16-length-prefixed payload\nAn arbitrary, unknown-content, u24-length-prefixed payload\nAn arbitrary, unknown-content, u8-length-prefixed payload\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThings we can encode and read from a Reader.\nRead from a byte slice.\nEncode yourself by appending onto <code>bytes</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvenience function to get the results of <code>encode()</code>.\nConvenience function to get the results of <code>encode()</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecode yourself by fiddling with the <code>Reader</code>. Return Some …\nRead one of these from the front of <code>bytes</code> and return it.\nRead one of these from the front of <code>bytes</code> and return it.\nThis deframer works to reconstruct TLS messages from …\nSet to true if the peer is not talking TLS, but some other …\nCompleted frames for output.\nReturns the argument unchanged.\nReturns true if we have messages for the caller to …\nCalls <code>U::from(self)</code>.\nRead some bytes from <code>rd</code>, and add them to our internal …\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nThe <code>AlertLevel</code> TLS protocol enum.  Values in this enum are …\nThe <code>CertificateStatusType</code> TLS protocol enum.  Values in …\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nThe <code>ClientCertificateType</code> TLS protocol enum.  Values in …\nThe <code>Compression</code> TLS protocol enum.  Values in this enum …\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe <code>ECCurveType</code> TLS protocol enum.  Values in this enum …\nThe <code>ECPointFormat</code> TLS protocol enum.  Values in this enum …\nThe <code>ExtensionType</code> TLS protocol enum.  Values in this enum …\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nThe <code>HeartbeatMessageType</code> TLS protocol enum.  Values in …\nThe <code>HeartbeatMode</code> TLS protocol enum.  Values in this enum …\nThe <code>KeyUpdateRequest</code> TLS protocol enum.  Values in this …\nThe <code>NamedCurve</code> TLS protocol enum.  Values in this enum are …\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nThe <code>PSKKeyExchangeMode</code> TLS protocol enum.  Values in this …\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nThe <code>ServerNameType</code> TLS protocol enum.  Values in this enum …\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the Message <code>msg</code> and re-fragment it into new messages …\nEnqueue borrowed fragments of (version, typ, payload) which\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMake a new fragmenter.\nOnly supports OCSP\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nRFC6066: “The ServerNameList MUST NOT contain more than …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a basic SNI ServerNameRequest quoting <code>hostname</code>.\nMake a new one with one entry.\nThis works to reconstruct TLS handshake messages from …\nCompleted handshake frames for output.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDo we have any buffered data?\nMake a new HandshakeJoiner.\nTake the message, and join/split it as needed. Return the …\nDo we want to process this message?\nA TLS frame, named TLSPlaintext in the standard.\nMaximum on-wire message size.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\n<code>MessageError</code> allows callers to distinguish between valid …\nKeys for session resumption and tickets. Matching value is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInherent implementation of the <code>Codec::get_encoding()</code> …\nInherent implementation of the <code>Codec::get_encoding()</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>Codec::read()</code> with an extra <code>suite</code> argument.\nTest only: wind back epoch by delta seconds.\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nEphemeral ECDH on curve25519 (see RFC7748)\nThis section discusses vulnerabilities in other TLS …\nThis section discusses vulnerabilities and design errors …\nThis section collects together goal-oriented documentation.\nThis section documents rustls itself: what protocol …\nThis section provides rationale for the defaults in rustls.\nRepresents a <code>ClientHello</code> message received through the …\nHandle on a server-side connection before configuration is …\nA <code>ClientCertVerifier</code> that will allow both anonymous and …\nA <code>ClientCertVerifier</code> that will ensure that every client …\nA struct representing the received Client Hello\nTurns off client authentication.\nSomething which never stores sessions.\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nSomething that resolves do different cert chains/keys based\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nAn implementer of <code>StoresServerSessions</code> that stores …\nA trait for the ability to store server session data.\nA config builder state where the caller must supply how to …\nCheck if a <code>ClientHello</code> message has been received.\nAdd a new <code>sign::CertifiedKey</code> to be used for the given SNI …\nGet the alpn.\nProtocol names we support, most preferred first. If empty …\nCreate builder to build up the server configuration.\nWhether the store can cache another session. This is used …\nHow to choose a server cert and key.\nGet cipher suites.\nGet the <code>ClientHello</code> for this connection.\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturns an <code>io::Read</code> implementer you can read bytes from …\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Accepted</code> into a <code>ServerConnection</code>.\nHow to output key material for debugging.  The default …\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of TLS message we’ll emit.  If None, we …\nConstruct a new <code>AllowAnyAuthenticatedClient</code>.\nConstruct a new <code>AllowAnyAnonymousOrAuthenticatedClient</code>.\nConstructs a <code>NoClientAuth</code> and wraps it in an <code>Arc</code>.\nMake a new ServerSessionMemoryCache.  <code>size</code> is the maximum …\nCreate a new and empty (i.e., knows no certificates) …\nMake a new ServerConnection.  <code>config</code> controls how we …\nCreate a new <code>Acceptor</code>.\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nRead TLS content from <code>rd</code>.\nApplication-controlled portion of the resumption ticket …\nExplicitly discard early data, notifying the client\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nGet the server name indicator.\nHow to store client sessions.\nSet the resumption data to embed in future resumption …\nGet the compatible signature schemes.\nRetrieves the SNI hostname, if any, used to select the …\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nReturns true if the caller should call …\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nErrors while signing\nA thing that can sign a message.\nAn abstract signing key.\nWhat kind of key we have.\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nThe certificate chain.\nChoose a <code>SignatureScheme</code> from those offered.\nThe end-entity certificate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe certified key.\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nReveals which scheme will be used when you call <code>sign()</code>.\nAn optional collection of SCTs from CT logs, proving the …\nSigns <code>message</code> using the selected scheme.\nThe set of schemes we support for signatures and that are …\nTLS1.2\nTLS1.3")