<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Tokio runtime."><title>tokio::runtime - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../tokio/index.html">tokio</a><span class="version">1.20.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module runtime</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a><ul><li><a href="#runtime-configurations" title="Runtime Configurations">Runtime Configurations</a></li><li><a href="#lifetime-of-spawned-threads" title="Lifetime of spawned threads">Lifetime of spawned threads</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate tokio</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">tokio</a></span><h1>Module <span>runtime</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/tokio/runtime/mod.rs.html#1-630">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The Tokio runtime.</p>
<p>Unlike other Rust programs, asynchronous applications require runtime
support. In particular, the following runtime services are necessary:</p>
<ul>
<li>An <strong>I/O event loop</strong>, called the driver, which drives I/O resources and
dispatches I/O events to tasks that depend on them.</li>
<li>A <strong>scheduler</strong> to execute <a href="../task/index.html" title="mod tokio::task">tasks</a> that use these I/O resources.</li>
<li>A <strong>timer</strong> for scheduling work to run after a set period of time.</li>
</ul>
<p>Tokio’s <a href="struct.Runtime.html" title="struct tokio::runtime::Runtime"><code>Runtime</code></a> bundles all of these services as a single type, allowing
them to be started, shut down, and configured together. However, often it is
not required to configure a <a href="struct.Runtime.html" title="struct tokio::runtime::Runtime"><code>Runtime</code></a> manually, and a user may just use the
<a href="../attr.main.html"><code>tokio::main</code></a> attribute macro, which creates a <a href="struct.Runtime.html" title="struct tokio::runtime::Runtime"><code>Runtime</code></a> under the hood.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>When no fine tuning is required, the <a href="../attr.main.html"><code>tokio::main</code></a> attribute macro can be
used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::net::TcpListener;
<span class="kw">use </span>tokio::io::{AsyncReadExt, AsyncWriteExt};

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="kw">let </span>listener = TcpListener::bind(<span class="string">"127.0.0.1:8080"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">loop </span>{
        <span class="kw">let </span>(<span class="kw-2">mut </span>socket, <span class="kw">_</span>) = listener.accept().<span class="kw">await</span><span class="question-mark">?</span>;

        tokio::spawn(<span class="kw">async move </span>{
            <span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0</span>; <span class="number">1024</span>];

            <span class="comment">// In a loop, read data from the socket and write the data back.
            </span><span class="kw">loop </span>{
                <span class="kw">let </span>n = <span class="kw">match </span>socket.read(<span class="kw-2">&amp;mut </span>buf).<span class="kw">await </span>{
                    <span class="comment">// socket closed
                    </span><span class="prelude-val">Ok</span>(n) <span class="kw">if </span>n == <span class="number">0 </span>=&gt; <span class="kw">return</span>,
                    <span class="prelude-val">Ok</span>(n) =&gt; n,
                    <span class="prelude-val">Err</span>(e) =&gt; {
                        <span class="macro">println!</span>(<span class="string">"failed to read from socket; err = {:?}"</span>, e);
                        <span class="kw">return</span>;
                    }
                };

                <span class="comment">// Write the data back
                </span><span class="kw">if let </span><span class="prelude-val">Err</span>(e) = socket.write_all(<span class="kw-2">&amp;</span>buf[<span class="number">0</span>..n]).<span class="kw">await </span>{
                    <span class="macro">println!</span>(<span class="string">"failed to write to socket; err = {:?}"</span>, e);
                    <span class="kw">return</span>;
                }
            }
        });
    }
}</code></pre></div>
<p>From within the context of the runtime, additional tasks are spawned using
the <a href="../task/fn.spawn.html" title="fn tokio::task::spawn"><code>tokio::spawn</code></a> function. Futures spawned using this function will be
executed on the same thread pool used by the <a href="struct.Runtime.html" title="struct tokio::runtime::Runtime"><code>Runtime</code></a>.</p>
<p>A <a href="struct.Runtime.html" title="struct tokio::runtime::Runtime"><code>Runtime</code></a> instance can also be used directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::net::TcpListener;
<span class="kw">use </span>tokio::io::{AsyncReadExt, AsyncWriteExt};
<span class="kw">use </span>tokio::runtime::Runtime;

<span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="comment">// Create the runtime
    </span><span class="kw">let </span>rt  = Runtime::new()<span class="question-mark">?</span>;

    <span class="comment">// Spawn the root task
    </span>rt.block_on(<span class="kw">async </span>{
        <span class="kw">let </span>listener = TcpListener::bind(<span class="string">"127.0.0.1:8080"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="kw">loop </span>{
            <span class="kw">let </span>(<span class="kw-2">mut </span>socket, <span class="kw">_</span>) = listener.accept().<span class="kw">await</span><span class="question-mark">?</span>;

            tokio::spawn(<span class="kw">async move </span>{
                <span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0</span>; <span class="number">1024</span>];

                <span class="comment">// In a loop, read data from the socket and write the data back.
                </span><span class="kw">loop </span>{
                    <span class="kw">let </span>n = <span class="kw">match </span>socket.read(<span class="kw-2">&amp;mut </span>buf).<span class="kw">await </span>{
                        <span class="comment">// socket closed
                        </span><span class="prelude-val">Ok</span>(n) <span class="kw">if </span>n == <span class="number">0 </span>=&gt; <span class="kw">return</span>,
                        <span class="prelude-val">Ok</span>(n) =&gt; n,
                        <span class="prelude-val">Err</span>(e) =&gt; {
                            <span class="macro">println!</span>(<span class="string">"failed to read from socket; err = {:?}"</span>, e);
                            <span class="kw">return</span>;
                        }
                    };

                    <span class="comment">// Write the data back
                    </span><span class="kw">if let </span><span class="prelude-val">Err</span>(e) = socket.write_all(<span class="kw-2">&amp;</span>buf[<span class="number">0</span>..n]).<span class="kw">await </span>{
                        <span class="macro">println!</span>(<span class="string">"failed to write to socket; err = {:?}"</span>, e);
                        <span class="kw">return</span>;
                    }
                }
            });
        }
    })
}</code></pre></div>
<h3 id="runtime-configurations"><a class="doc-anchor" href="#runtime-configurations">§</a>Runtime Configurations</h3>
<p>Tokio provides multiple task scheduling strategies, suitable for different
applications. The <a href="struct.Builder.html" title="struct tokio::runtime::Builder">runtime builder</a> or <code>#[tokio::main]</code> attribute may be
used to select which scheduler to use.</p>
<h5 id="multi-thread-scheduler"><a class="doc-anchor" href="#multi-thread-scheduler">§</a>Multi-Thread Scheduler</h5>
<p>The multi-thread scheduler executes futures on a <em>thread pool</em>, using a
work-stealing strategy. By default, it will start a worker thread for each
CPU core available on the system. This tends to be the ideal configuration
for most applications. The multi-thread scheduler requires the <code>rt-multi-thread</code>
feature flag, and is selected by default:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::runtime;

<span class="kw">let </span>threaded_rt = runtime::Runtime::new()<span class="question-mark">?</span>;</code></pre></div>
<p>Most applications should use the multi-thread scheduler, except in some
niche use-cases, such as when running only a single thread is required.</p>
<h5 id="current-thread-scheduler"><a class="doc-anchor" href="#current-thread-scheduler">§</a>Current-Thread Scheduler</h5>
<p>The current-thread scheduler provides a <em>single-threaded</em> future executor.
All tasks will be created and executed on the current thread. This requires
the <code>rt</code> feature flag.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::runtime;

<span class="kw">let </span>basic_rt = runtime::Builder::new_current_thread()
    .build()<span class="question-mark">?</span>;</code></pre></div>
<h5 id="resource-drivers"><a class="doc-anchor" href="#resource-drivers">§</a>Resource drivers</h5>
<p>When configuring a runtime by hand, no resource drivers are enabled by
default. In this case, attempting to use networking types or time types will
fail. In order to enable these types, the resource drivers must be enabled.
This is done with <a href="struct.Builder.html#method.enable_io" title="method tokio::runtime::Builder::enable_io"><code>Builder::enable_io</code></a> and <a href="struct.Builder.html#method.enable_time" title="method tokio::runtime::Builder::enable_time"><code>Builder::enable_time</code></a>. As a
shorthand, <a href="struct.Builder.html#method.enable_all" title="method tokio::runtime::Builder::enable_all"><code>Builder::enable_all</code></a> enables both resource drivers.</p>
<h3 id="lifetime-of-spawned-threads"><a class="doc-anchor" href="#lifetime-of-spawned-threads">§</a>Lifetime of spawned threads</h3>
<p>The runtime may spawn threads depending on its configuration and usage. The
multi-thread scheduler spawns threads to schedule tasks and for <code>spawn_blocking</code>
calls.</p>
<p>While the <code>Runtime</code> is active, threads may shutdown after periods of being
idle. Once <code>Runtime</code> is dropped, all runtime threads are forcibly shutdown.
Any tasks that have not yet completed will be dropped.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Builder.html" title="struct tokio::runtime::Builder">Builder</a></div><div class="desc docblock-short">Builds Tokio Runtime with custom configuration values.</div></li><li><div class="item-name"><a class="struct" href="struct.EnterGuard.html" title="struct tokio::runtime::EnterGuard">Enter<wbr>Guard</a></div><div class="desc docblock-short">Runtime context guard.</div></li><li><div class="item-name"><a class="struct" href="struct.Handle.html" title="struct tokio::runtime::Handle">Handle</a></div><div class="desc docblock-short">Handle to the runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.Runtime.html" title="struct tokio::runtime::Runtime">Runtime</a></div><div class="desc docblock-short">The Tokio runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.TryCurrentError.html" title="struct tokio::runtime::TryCurrentError">TryCurrent<wbr>Error</a></div><div class="desc docblock-short">Error returned by <code>try_current</code> when no Runtime has been started</div></li></ul></section></div></main></body></html>