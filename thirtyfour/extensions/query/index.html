<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Advanced query interface featuring powerful filtering and polling options."><title>thirtyfour::extensions::query - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="thirtyfour" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.1 (7cf61ebde 2024-03-27)" data-channel="1.77.1" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../thirtyfour/index.html">thirtyfour</a><span class="version">0.31.0</span></h2></div><h2 class="location"><a href="#">Module query</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In thirtyfour::extensions</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../thirtyfour/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">thirtyfour</a>::<wbr><a href="../index.html">extensions</a>::<wbr><a class="mod" href="#">query</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/thirtyfour/extensions/query/mod.rs.html#1-144">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Advanced query interface featuring powerful filtering and polling options.</p>
<p>See examples for more details.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3><h4 id="elementquery"><a class="doc-anchor" href="#elementquery">§</a>ElementQuery</h4>
<p>The <code>WebDriver::query()</code> and <code>WebElement::query()</code> methods work out-of-the-box with no
additional setup required. However, you can customize some of the behaviour if needed.</p>
<p>Now, using the query interface you can do things like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This will only poll once and then return a bool immediately.
</span><span class="kw">let </span>is_found = driver
    .query(By::Id(<span class="string">"button1"</span>))
    .nowait()
    .exists()
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// This will poll until either branch matches at least one element.
// Only the first matched element will be returned.
</span><span class="kw">let </span>elem = driver
    .query(By::Css(<span class="string">"thiswont.match"</span>))
    .or(By::Id(<span class="string">"button1"</span>))
    .first()
    .<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>This will execute both queries once per poll iteration and return the first one that matches.</p>
<p>You can also filter on one or both query branches like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>thirtyfour::stringmatch::StringMatch;
<span class="kw">let </span>elem = driver
    .query(By::Css(<span class="string">"thiswont.match"</span>))
    .with_text(<span class="string">"testing"</span>)
    .or(By::Id(<span class="string">"button1"</span>))
    .with_class(StringMatch::new(<span class="string">"pure-button"</span>).word())
    .and_enabled()
    .first()
    .<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Note the use of <code>StringMatch</code> to provide a partial (whole-word) match on the class name.
See the documentation for <a href="https://crates.io/crates/stringmatch">StringMatch</a> for more info.</p>
<p><strong>NOTE:</strong> Each filter will trigger an additional request to the WebDriver server for every poll
iteration. It is therefore strongly recommended to use <code>By::*</code> selectors to perform filtering,
if possible. The <code>By::Css</code> and <code>By::XPath</code> selectors may be required for more complex
filters.</p>
<p>To fetch all matching elements instead of just the first one, simply change <code>first()</code> to <code>all()</code>
and you’ll get a Vec instead. Note that <code>all()</code> will return only the elements from the query
branch that first matched something. In the above example, if the
<code>(By::Css(&quot;branch.one&quot;)).with_text(&quot;testing&quot;)</code> branch returned at least one element, then only
those elements will be returned from an <code>all()</code> call even if the other branch would have
matched something. If you want to fetch all elements matched by all branches,
it’s probably best to execute multiple queries.</p>
<p>All timeout, interval and ElementPoller details can be overridden on a per-call basis if
desired. See the <a href="struct.ElementQuery.html" title="struct thirtyfour::extensions::query::ElementQuery"><code>ElementQuery</code></a> documentation for more details.</p>
<h4 id="elementwaiter"><a class="doc-anchor" href="#elementwaiter">§</a>ElementWaiter</h4>
<p>With <code>ElementWaiter</code> you can do things like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>elem.wait_until().displayed().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="comment">// You can optionally provide a nicer error message like this.
</span>elem.wait_until().error(<span class="string">"Timed out waiting for element to disappear"</span>).not_displayed().<span class="kw">await</span><span class="question-mark">?</span>;

elem.wait_until().enabled().<span class="kw">await</span><span class="question-mark">?</span>;
elem.wait_until().clickable().<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>And so on. See the <a href="struct.ElementWaiter.html" title="struct thirtyfour::extensions::query::ElementWaiter"><code>ElementWaiter</code></a> docs for the full
list of predicates available.</p>
<p><code>ElementWaiter</code> also allows the user of custom predicates that take a <code>&amp;WebElement</code> argument
and return a <code>WebDriverResult&lt;bool&gt;</code>.</p>
<p>A range of pre-defined predicates are also supplied for convenience in the
<code>thirtyfour::extensions::query::conditions</code> module.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>thirtyfour_query::conditions;

elem.wait_until().conditions(<span class="macro">vec!</span>[
    conditions::element_is_displayed(<span class="bool-val">true</span>),
    conditions::element_is_clickable(<span class="bool-val">true</span>)
]).<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Take a look at the <code>conditions</code> module for the full list of predicates available.
NOTE: Predicates require you to specify whether or not errors should be ignored.</p>
<p>These predicates (or your own) can also be supplied as filters to <code>ElementQuery</code>.</p>
<h4 id="elementpoller"><a class="doc-anchor" href="#elementpoller">§</a>ElementPoller</h4>
<p>The polling strategy can be customized by implementing both <a href="trait.ElementPoller.html" title="trait thirtyfour::extensions::query::ElementPoller"><code>ElementPoller</code></a>
and <a href="trait.IntoElementPoller.html" title="trait thirtyfour::extensions::query::IntoElementPoller"><code>IntoElementPoller</code></a>.</p>
<p>See <a href="struct.ElementPollerWithTimeout.html" title="struct thirtyfour::extensions::query::ElementPollerWithTimeout"><code>ElementPollerWithTimeout</code></a> for more details about the default polling behaviour.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="conditions/index.html" title="mod thirtyfour::extensions::query::conditions">conditions</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ElementPollerNoWait.html" title="struct thirtyfour::extensions::query::ElementPollerNoWait">ElementPollerNoWait</a></div><div class="desc docblock-short">No polling, single attempt.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementPollerWithTimeout.html" title="struct thirtyfour::extensions::query::ElementPollerWithTimeout">ElementPollerWithTimeout</a></div><div class="desc docblock-short">Poll up to the specified timeout, with the specified interval being the
minimum time elapsed between the start of each poll attempt.
If the previous poll attempt took longer than the interval, the next will
start immediately. Once the timeout is reached, a Timeout error will be
returned regardless of the actual number of polling attempts completed.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementQuery.html" title="struct thirtyfour::extensions::query::ElementQuery">ElementQuery</a></div><div class="desc docblock-short">High-level interface for performing powerful element queries using a
builder pattern.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementQueryOptions.html" title="struct thirtyfour::extensions::query::ElementQueryOptions">ElementQueryOptions</a></div><div class="desc docblock-short">All options applicable to an ElementQuery.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementSelector.html" title="struct thirtyfour::extensions::query::ElementSelector">ElementSelector</a></div><div class="desc docblock-short">An ElementSelector contains a selector method (By) as well as zero or more filters.
The filters will be applied to any elements matched by the selector.
Selectors and filters all run in full on every poll iteration.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementWaiter.html" title="struct thirtyfour::extensions::query::ElementWaiter">ElementWaiter</a></div><div class="desc docblock-short">High-level interface for performing explicit waits using the builder pattern.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ElementQuerySource.html" title="enum thirtyfour::extensions::query::ElementQuerySource">ElementQuerySource</a></div><div class="desc docblock-short">Elements can be queried from either a WebDriver or from a WebElement.
The command issued to the webdriver will differ depending on the source,
i.e. FindElement vs FindElementFromElement etc. but the ElementQuery
interface is the same for both.</div></li><li><div class="item-name"><a class="enum" href="enum.ElementQueryWaitOptions.html" title="enum thirtyfour::extensions::query::ElementQueryWaitOptions">ElementQueryWaitOptions</a></div><div class="desc docblock-short">Options for wait characteristics for an element query.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ElementPoller.html" title="trait thirtyfour::extensions::query::ElementPoller">ElementPoller</a></div><div class="desc docblock-short">Trait for implementing the element polling strategy.</div></li><li><div class="item-name"><a class="trait" href="trait.ElementQueryable.html" title="trait thirtyfour::extensions::query::ElementQueryable">ElementQueryable</a></div><div class="desc docblock-short">Trait for enabling the ElementQuery interface.</div></li><li><div class="item-name"><a class="trait" href="trait.ElementWaitable.html" title="trait thirtyfour::extensions::query::ElementWaitable">ElementWaitable</a></div><div class="desc docblock-short">Trait for enabling the ElementWaiter interface.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoElementPoller.html" title="trait thirtyfour::extensions::query::IntoElementPoller">IntoElementPoller</a></div><div class="desc docblock-short">Trait for returning a struct that implements ElementPoller.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.filter_elements.html" title="fn thirtyfour::extensions::query::filter_elements">filter_elements</a></div></li></ul></section></div></main></body></html>