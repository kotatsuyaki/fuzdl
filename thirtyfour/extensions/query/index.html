<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Extensions for working with Chromium-based browsers. Advanced query interface featuring powerful filtering and polling options."><meta name="keywords" content="rust, rustlang, rust-lang, query"><title>thirtyfour::extensions::query - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../thirtyfour/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../thirtyfour/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module query</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="query" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../thirtyfour/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../../index.html">thirtyfour</a>::<wbr><a href="../index.html">extensions</a>::<wbr><a class="mod" href="#">query</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/thirtyfour/extensions/query/mod.rs.html#1-163">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Extensions for working with Chromium-based browsers.
Advanced query interface featuring powerful filtering and polling options.</p>
<p>See examples for more details.</p>
<h3 id="usage"><a href="#usage">Usage</a></h3><h4 id="elementquery"><a href="#elementquery">ElementQuery</a></h4>
<p>The <code>WebDriver::query()</code> and <code>WebElement::query()</code> methods work out-of-the-box with no
additional setup required. However, you can customize some of the behaviour if needed.</p>
<p>Now, using the query interface you can do things like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This will only poll once and then return a bool immediately.</span>
<span class="kw">let</span> <span class="ident">is_found</span> <span class="op">=</span> <span class="ident">driver</span>.<span class="ident">query</span>(<span class="ident">By::Id</span>(<span class="string">&quot;button1&quot;</span>)).<span class="ident">nowait</span>().<span class="ident">exists</span>().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// This will poll until either branch matches at least one element.</span>
<span class="comment">// Only the first matched element will be returned.</span>
<span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">driver</span>.<span class="ident">query</span>(<span class="ident">By::Css</span>(<span class="string">&quot;thiswont.match&quot;</span>)).<span class="ident">or</span>(<span class="ident">By::Id</span>(<span class="string">&quot;button1&quot;</span>)).<span class="ident">first</span>().<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>This will execute both queries once per poll iteration and return the first one that matches.</p>
<p>You can also filter on one or both query branches like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">driver</span>.<span class="ident">query</span>(<span class="ident">By::Css</span>(<span class="string">&quot;thiswont.match&quot;</span>)).<span class="ident">with_text</span>(<span class="string">&quot;testing&quot;</span>)
    .<span class="ident">or</span>(<span class="ident">By::Id</span>(<span class="string">&quot;button1&quot;</span>)).<span class="ident">with_class</span>(<span class="ident">StringMatch::new</span>(<span class="string">&quot;pure-button&quot;</span>).<span class="ident">word</span>()).<span class="ident">and_enabled</span>()
    .<span class="ident">first</span>().<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Note the use of <code>StringMatch</code> to provide a partial (whole-word) match on the class name.
See the documentation for <a href="https://crates.io/crates/stringmatch">StringMatch</a> for more info.</p>
<p><strong>NOTE:</strong> Each filter will trigger an additional request to the WebDriver server for every poll
iteration. It is therefore strongly recommended to use <code>By::*</code> selectors to perform filtering,
if possible. The <code>By::Css</code> and <code>By::XPath</code> selectors may be required for more complex
filters.</p>
<p>To fetch all matching elements instead of just the first one, simply change <code>first()</code> to <code>all()</code>
and you’ll get a Vec instead. Note that <code>all()</code> will return only the elements from the query
branch that first matched something. In the above example, if the
<code>(By::Css(&quot;branch.one&quot;)).with_text(&quot;testing&quot;)</code> branch returned at least one element, then only
those elements will be returned from an <code>all()</code> call even if the other branch would have
matched something. If you want to fetch all elements matched by all branches,
it’s probably best to execute multiple queries.</p>
<p>All timeout, interval and ElementPoller details can be overridden on a per-call basis if
desired. See the <a href="struct.ElementQuery.html">ElementQuery</a> documentation for more details.</p>
<h4 id="elementwaiter"><a href="#elementwaiter">ElementWaiter</a></h4>
<p>With <code>ElementWaiter</code> you can do things like this:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="ident">elem</span>.<span class="ident">wait_until</span>().<span class="ident">displayed</span>().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="comment">// You can optionally provide a nicer error message like this.</span>
<span class="ident">elem</span>.<span class="ident">wait_until</span>().<span class="ident">error</span>(<span class="string">&quot;Timed out waiting for element to disappear&quot;</span>).<span class="ident">not_displayed</span>().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="ident">elem</span>.<span class="ident">wait_until</span>().<span class="ident">enabled</span>().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="ident">elem</span>.<span class="ident">wait_until</span>().<span class="ident">clickable</span>().<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>And so on. See the <a href="struct.ElementWaiter.html">ElementWaiter</a> docs for the full
list of predicates available.</p>
<p><code>ElementWaiter</code> also allows the user of custom predicates that take a <code>&amp;WebElement</code> argument
and return a <code>WebDriverResult&lt;bool&gt;</code>.</p>
<p>A range of pre-defined predicates are also supplied for convenience in the
<code>thirtyfour::query::conditions</code> module.</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">use</span> <span class="ident">thirtyfour_query::conditions</span>;

<span class="ident">elem</span>.<span class="ident">wait_until</span>().<span class="ident">conditions</span>(<span class="macro">vec!</span>[
    <span class="ident">conditions::element_is_displayed</span>(<span class="bool-val">true</span>),
    <span class="ident">conditions::element_is_clickable</span>(<span class="bool-val">true</span>)
]).<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Take a look at the <code>conditions</code> module for the full list of predicates available.
NOTE: Predicates require you to specify whether or not errors should be ignored.</p>
<p>These predicates (or your own) can also be supplied as filters to <code>ElementQuery</code>.</p>
<h4 id="elementpoller"><a href="#elementpoller">ElementPoller</a></h4>
<p>You can optionally change the default polling behaviour. The same poller will apply to
both <code>ElementQuery</code> and <code>ElementWaiter</code>.</p>
<p>See <a href="enum.ElementPoller.html#impl-Default">ElementPoller::default()</a> for more details
about the default polling behaviour.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">poller</span> <span class="op">=</span> <span class="ident">ElementPoller::TimeoutWithInterval</span>(<span class="ident">Duration::new</span>(<span class="number">10</span>, <span class="number">0</span>), <span class="ident">Duration::from_millis</span>(<span class="number">500</span>));
<span class="ident">driver</span>.<span class="ident">set_query_poller</span>(<span class="ident">poller</span>);</code></pre></div>
<p>Other <a href="enum.ElementPoller.html">ElementPoller</a> options are also available, such as
<code>NoWait</code> and <code>NumTriesWithInterval</code>.
These can also be overridden on a per-query basis if needed.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="conditions/index.html" title="thirtyfour::extensions::query::conditions mod">conditions</a></div><div class="item-right docblock-short"></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ElementPollerTicker.html" title="thirtyfour::extensions::query::ElementPollerTicker struct">ElementPollerTicker</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ElementQuery.html" title="thirtyfour::extensions::query::ElementQuery struct">ElementQuery</a></div><div class="item-right docblock-short"><p>High-level interface for performing powerful element queries using a
builder pattern.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ElementSelector.html" title="thirtyfour::extensions::query::ElementSelector struct">ElementSelector</a></div><div class="item-right docblock-short"><p>An ElementSelector contains a selector method (By) as well as zero or more filters.
The filters will be applied to any elements matched by the selector.
Selectors and filters all run in full on every poll iteration.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ElementWaiter.html" title="thirtyfour::extensions::query::ElementWaiter struct">ElementWaiter</a></div><div class="item-right docblock-short"><p>High-level interface for performing explicit waits using the builder pattern.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StringMatch.html" title="thirtyfour::extensions::query::StringMatch struct">StringMatch</a></div><div class="item-right docblock-short"><p>Re-export stringmatch::StringMatch for convenience.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ElementPoller.html" title="thirtyfour::extensions::query::ElementPoller enum">ElementPoller</a></div><div class="item-right docblock-short"><p>Parameters used to determine the polling / timeout behaviour.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ElementQuerySource.html" title="thirtyfour::extensions::query::ElementQuerySource enum">ElementQuerySource</a></div><div class="item-right docblock-short"><p>Elements can be queried from either a WebDriver or from a WebElement.
The command issued to the webdriver will differ depending on the source,
i.e. FindElement vs FindElementFromElement etc. but the ElementQuery
interface is the same for both.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ElementQueryable.html" title="thirtyfour::extensions::query::ElementQueryable trait">ElementQueryable</a></div><div class="item-right docblock-short"><p>Trait for enabling the ElementQuery interface.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ElementWaitable.html" title="thirtyfour::extensions::query::ElementWaitable trait">ElementWaitable</a></div><div class="item-right docblock-short"><p>Trait for enabling the ElementWaiter interface.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.filter_elements.html" title="thirtyfour::extensions::query::filter_elements fn">filter_elements</a></div><div class="item-right docblock-short"></div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.ElementPredicate.html" title="thirtyfour::extensions::query::ElementPredicate type">ElementPredicate</a></div><div class="item-right docblock-short"><p>Function signature for element predicates.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="thirtyfour" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>