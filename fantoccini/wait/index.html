<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Allow to wait for conditions."><title>fantoccini::wait - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="fantoccini" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../fantoccini/index.html">fantoccini</a><span class="version">0.19.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module wait</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basic-usage" title="Basic usage">Basic usage</a></li><li><a href="#error-handling" title="Error handling">Error handling</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate fantoccini</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">fantoccini</a></span><h1>Module <span>wait</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/fantoccini/wait.rs.html#1-156">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Allow to wait for conditions.</p>
<p>Sometimes it is necessary to wait for a browser to achieve a certain state. For example,
navigating to a page may be take bit of time. And the time may vary between different
environments and test runs. Static delays can work around this issue, but also prolong the
test runs unnecessarily. Longer delays have less flaky tests, but even more unnecessary wait
time.</p>
<p>To wait as optimal as possible, you can use asynchronous wait operations, which periodically
check for the expected state, re-try if necessary, but also fail after a certain time and still
allow you to fail the test. Allow for longer grace periods, and only spending the time waiting
when necessary.</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">ยง</a>Basic usage</h2>
<p>By default all wait operations will time-out after 30 seconds and will re-check every
250 milliseconds. You can configure this using the <a href="struct.Wait.html#method.at_most" title="method fantoccini::wait::Wait::at_most"><code>Wait::at_most</code></a> and <a href="struct.Wait.html#method.every" title="method fantoccini::wait::Wait::every"><code>Wait::every</code></a>
methods or use <a href="struct.Wait.html#method.forever" title="method fantoccini::wait::Wait::forever"><code>Wait::forever</code></a> to wait indefinitely.</p>
<p>Once configured, you can start waiting on some condition by using the <code>Wait::for_*</code> methods.
For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// -- snip wrapper code --
</span><span class="kw">let </span>button = client.wait().for_element(Locator::Css(
    <span class="string">r#"a.button-download[href="/learn/get-started"]"#</span>,
)).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="comment">// -- snip wrapper code --</span></code></pre></div>
<h2 id="error-handling"><a class="doc-anchor" href="#error-handling">ยง</a>Error handling</h2>
<p>When a wait operation times out, it will return a <a href="../error/enum.CmdError.html#variant.WaitTimeout" title="variant fantoccini::error::CmdError::WaitTimeout"><code>CmdError::WaitTimeout</code></a>. When a wait
condition check returns an error, the wait operation will be aborted, and the error returned.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Wait.html" title="struct fantoccini::wait::Wait">Wait</a></div><div class="desc docblock-short">Used for setting up a wait operation on the client.</div></li></ul></section></div></main></body></html>